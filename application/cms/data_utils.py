import pandas as pd
import numpy as np


class Harmoniser:
    default_sort_value = 800
    default_ethnicity_columns = ['ethnicity']
    default_ethnicity_type_columns = ['ethnicity type', 'ethnicity_type', 'ethnicity-type']

    """
    Harmoniser adds four fields to an ethnicity data set.
    Label                   A harmonised version of the ethnicity name
    Parent-child label      A harmonised version of ethnicity name including the parent name
    Parent                  The name of the ethnicity's parent
    Sort                    An Integer

    Using these four fields we can explore more advanced data options

    Harmoniser relies on keeping a csv up to date with appropriate values for data being used on the platform
    """
    def __init__(self, lookup_file):
        self.lookup = pd.read_csv(lookup_file, header=0)
        self.lookup[['Ethnicity', 'Ethnicity_type', 'Label', 'Parent prefix', 'Parent']].fillna('')
        self.lookup['Sort'].fillna(value=0)

    def process_data(self, data, ethnicity_name='', ethnicity_type_name=''):
        headers = data.pop(0)
        try:
            if ethnicity_name != '':
                ethnicity_index = self.find_column(headers, [ethnicity_name])
            else:
                ethnicity_index = self.find_column(headers, self.default_ethnicity_columns)
        except ValueError:
            data.insert(0, headers)
            return data

        try:
            if ethnicity_type_name != '':
                ethnicity_type_index = self.find_column(headers, [ethnicity_type_name])
            else:
                ethnicity_type_index = self.find_column(headers, self.default_ethnicity_type_columns)
        except ValueError:
            # default ethnicity type index to use the ethnicity column (essentially ignore ethnicity types)
            ethnicity_type_index = ethnicity_index

        self.append_columns(data, ethnicity_column=ethnicity_index, ethnicity_type_column=ethnicity_type_index)
        headers.extend(['Ethnicity-1', 'Ethnicity-2', 'Parent', 'Order'])
        data.insert(0, headers)

        return data

    def find_column(self, headers, column_names):
        lower_headers = [h.lower() for h in headers]
        for column_name in column_names:
            try:
                index = lower_headers.index(column_name.lower())
                return index
            except ValueError:
                pass
        raise ValueError

    def append_columns(self, data, ethnicity_column=0, ethnicity_type_column=1):

        for item in data:
            filtered = self.lookup[item[ethnicity_column] == self.lookup['Ethnicity']]
            double_filtered = filtered[item[ethnicity_type_column] == self.lookup['Ethnicity_type']]
            if double_filtered.__len__() > 0:
                self.append_lookup_values(double_filtered, item)
            elif filtered.__len__() > 0:
                self.append_lookup_values(filtered, item)
            else:
                item.extend([item[ethnicity_column], item[ethnicity_column], '', self.default_sort_value])

    def append_lookup_values(self, lookup_row, item):

        self.try_append(lookup_row.iloc[0].values[2], item)  # Label
        self.try_append(lookup_row.iloc[0].values[3], item)  # Parent - Label
        self.try_append(lookup_row.iloc[0].values[4], item)  # Parent
        self.try_append(np.asscalar(lookup_row.iloc[0].values[5]), item)  # Sort order

    def try_append(self, value, item):
        try:
            if np.isnan(value):
                item.append('')
            else:
                item.append(value)
        except TypeError:
            item.append(value)


class Autogenerator:

    def autogenerate(self, page):
        for dimension in page.dimensions:
            if dimension.chart != '' and dimension.table == '':
                dimension.table = self.autotable(dimension.chart)

    def autotable(self, chart_object):
        if chart_object['type'] == 'bar':
            if chart_object['series'].__len__() == 1:
                return self.autotable_for_simple_bar_chart(chart_object)
            else:
                return self.autotable_categories_for_columns(chart_object)
        elif chart_object['type'] == 'line':
            if chart_object['xAxis']['categories'].__len__() <= 6:
                return self.autotable_categories_for_columns(chart_object)
            elif chart_object['series'].__len__() <= 6:
                return self.autotable_series_for_columns(chart_object)
            else:
                return self.autotable_for_line_chart(chart_object)
        elif chart_object['type'] == 'component':
            return self.autotable_series_for_columns(chart_object)

    def autotable_bar_chart_base(self, chart_object):
        table_object = {
            'autogenerated': True,
            'title': chart_object['title'],
            'category': chart_object['xAxis']['title']['text'],
            'columns': [chart_object['yAxis']['title']['text']]
        }
        return table_object

    def autotable_for_simple_bar_chart(self, chart_object):

        table_object = self.autotable_bar_chart_base(chart_object)
        table_object['type'] = 'simple'

        categories = chart_object['xAxis']['categories']
        series_data = chart_object['series'][0]['data']
        data = [{
            'category': categories[i],
            'values': [series_data[i]]
        } for i in range(0, len(categories))]

        table_object['data'] = data

        return table_object

    def autotable_categories_for_columns(self, chart_object):

        table_object = self.autotable_bar_chart_base(chart_object)
        table_object['type'] = 'grouped'

        groups = []
        categories = chart_object['xAxis']['categories']
        for series in chart_object['series']:
            series_data = series['data']
            group_data = [{
                'category': categories[i],
                'values': [series_data[i]]
            } for i in range(0, len(categories))]
            groups.append({
                'group': series['name'],
                'data': group_data
            })
        table_object['groups'] = groups

        return table_object

    def autotable_series_for_columns(self, chart_object):

        table_object = {
            'autogenerated': True,
            'title': chart_object['title'],
            'category': chart_object['xAxis']['title']['text'],
            'columns': [chart_object['yAxis']['title']['text']],
            'type': 'grouped'
        }

        groups = []
        categories = chart_object['xAxis']['categories']
        for c in range(0, len(categories)):
            category = categories[c]
            group_data = [{
                'category': series['name'],
                'values': [series['data'][c]]
            } for series in chart_object['series']]
            groups.append({
                'group': category,
                'data': group_data
            })
        table_object['groups'] = groups

        return table_object

    def autotable_for_line_chart(self, chart_object):
        table_object = {
            'autogenerated': True,
            'title': chart_object['title'],
            'category': 'Ethnicity',
            'columns': [chart_object['xAxis']['title']['text'], chart_object['yAxis']['title']['text']],
            'type': 'simple'
        }

        rows = []
        categories = chart_object['xAxis']['categories']  # time
        for c in range(0, len(categories)):
            category = categories[c]  # for each time point

            # add {'category':Ethnicity, values:['time', 'value']}
            group_data = [{
                'category': series['name'],
                'values': [category, series['data'][c]]
            } for series in chart_object['series']]

            rows.extend(group_data)

        table_object['data'] = rows

        return table_object
